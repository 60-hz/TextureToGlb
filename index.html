<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Texture to GLB Converter - Advanced</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #868686 0%, #353535 100%);
            min-height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }

        .container {
            background: white;
            border-radius: 20px;
            padding: 40px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            max-width: 700px;
            width: 100%;
        }

        h1 {
            color: #333;
            margin-bottom: 10px;
            font-size: 28px;
        }

        .subtitle {
            color: #666;
            margin-bottom: 25px;
            font-size: 14px;
        }

        /* Toggle Switch */
        .options-bar {
            background: #f0f2ff;
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 20px;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .toggle-container {
            display: flex;
            align-items: center;
            cursor: pointer;
        }

        .toggle-switch {
            position: relative;
            width: 50px;
            height: 26px;
            background-color: #ccc;
            border-radius: 20px;
            margin-right: 10px;
            transition: .4s;
        }

        .toggle-switch::before {
            content: "";
            position: absolute;
            height: 20px;
            width: 20px;
            left: 3px;
            bottom: 3px;
            background-color: white;
            border-radius: 50%;
            transition: .4s;
        }

        input:checked + .toggle-switch {
            background-color: #764ba2;
        }

        input:checked + .toggle-switch::before {
            transform: translateX(24px);
        }

        .toggle-label {
            font-weight: 600;
            color: #555;
        }

        /* Upload Grid */
        .upload-grid {
            display: grid;
            grid-template-columns: 1fr;
            gap: 20px;
            transition: all 0.3s ease;
        }

        .upload-grid.two-columns {
            grid-template-columns: 1fr 1fr;
        }

        .drop-zone {
            border: 3px dashed #868686;
            border-radius: 15px;
            padding: 30px 10px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
            background: #f8f9ff;
            position: relative;
            min-height: 200px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }

        .drop-zone:hover {
            border-color: #764ba2;
            background: #f0f2ff;
        }

        .drop-zone.active {
            border-color: #764ba2;
            background: #e8ebff;
        }

        .drop-zone.filled {
            border-style: solid;
            padding: 10px;
        }

        .drop-icon {
            font-size: 32px;
            margin-bottom: 10px;
        }

        .drop-text {
            color: #667eea;
            font-size: 16px;
            font-weight: 600;
            margin-bottom: 5px;
        }

        .drop-label {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(118, 75, 162, 0.1);
            color: #764ba2;
            padding: 4px 8px;
            border-radius: 5px;
            font-size: 12px;
            font-weight: bold;
        }

        .preview-thumb {
            max-width: 100%;
            max-height: 160px;
            border-radius: 8px;
            box-shadow: 0 4px 10px rgba(0,0,0,0.1);
        }

        /* Action Section */
        .action-section {
            margin-top: 30px;
        }

        .btn {
            background: linear-gradient(135deg, #868686 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 15px 40px;
            border-radius: 10px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
            width: 100%;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 20px rgba(102, 126, 234, 0.4);
        }

        .btn:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .status {
            margin-top: 15px;
            padding: 12px;
            border-radius: 8px;
            font-size: 14px;
            text-align: center;
            display: none;
        }

        .status.success { background: #d4edda; color: #155724; border: 1px solid #c3e6cb; }
        .status.error { background: #f8d7da; color: #721c24; border: 1px solid #f5c6cb; }
        
        #back-zone {
            display: none;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Texture to GLB</h1>
        <p class="subtitle">Convertir une texture (.jpg, .png) en modèles 3D : evite le bug d'animation d'image de Zapworks Designer et permet une image à double face.

</p>
        
        <div class="options-bar">
            <label class="toggle-container">
                <input type="checkbox" id="doubleFaceCheck" style="display:none">
                <div class="toggle-switch"></div>
                <span class="toggle-label">Double face (Recto/Verso différents)</span>
            </label>
        </div>

        <div class="upload-grid" id="uploadGrid">
            <div class="drop-zone" id="frontZone">
                <span class="drop-label">FACE AVANT</span>
                <div class="content-empty">
                    <div class="drop-icon">↓</div>
                    <div class="drop-text">Image Recto</div>
                </div>
                <img id="frontPreview" class="preview-thumb" style="display:none">
            </div>

            <div class="drop-zone" id="backZone" style="display:none">
                <span class="drop-label">FACE ARRIÈRE</span>
                <div class="content-empty">
                    <div class="drop-icon">↓</div>
                    <div class="drop-text">Image Verso</div>
                </div>
                <img id="backPreview" class="preview-thumb" style="display:none">
            </div>
        </div>

        <input type="file" id="frontInput" accept="image/jpeg,image/png" hidden>
        <input type="file" id="backInput" accept="image/jpeg,image/png" hidden>

        <div class="action-section">
            <button class="btn" id="convertBtn" disabled>Convertir en GLB</button>
            <div class="status" id="status"></div>
        </div>
    </div>

    <script>
        // --- State Management ---
        const state = {
            isDoubleFace: false,
            frontFile: null,
            backFile: null
        };

        // --- DOM Elements ---
        const doubleFaceCheck = document.getElementById('doubleFaceCheck');
        const uploadGrid = document.getElementById('uploadGrid');
        
        const frontZone = document.getElementById('frontZone');
        const backZone = document.getElementById('backZone');
        
        const frontInput = document.getElementById('frontInput');
        const backInput = document.getElementById('backInput');
        
        const frontPreview = document.getElementById('frontPreview');
        const backPreview = document.getElementById('backPreview');
        
        const convertBtn = document.getElementById('convertBtn');
        const status = document.getElementById('status');

        // --- Event Listeners ---

        // Toggle Switch
        doubleFaceCheck.addEventListener('change', (e) => {
            state.isDoubleFace = e.target.checked;
            if (state.isDoubleFace) {
                uploadGrid.classList.add('two-columns');
                backZone.style.display = 'flex';
            } else {
                uploadGrid.classList.remove('two-columns');
                backZone.style.display = 'none';
            }
            updateButtonState();
        });

        // Setup Drop Zones
        setupDropZone(frontZone, frontInput, 'front');
        setupDropZone(backZone, backInput, 'back');

        function setupDropZone(zone, input, type) {
            zone.addEventListener('click', () => input.click());
            
            zone.addEventListener('dragover', (e) => {
                e.preventDefault();
                zone.classList.add('active');
            });

            zone.addEventListener('dragleave', () => {
                zone.classList.remove('active');
            });

            zone.addEventListener('drop', (e) => {
                e.preventDefault();
                zone.classList.remove('active');
                if (e.dataTransfer.files.length) handleFile(e.dataTransfer.files[0], type);
            });

            input.addEventListener('change', (e) => {
                if (e.target.files.length) handleFile(e.target.files[0], type);
            });
        }

        function handleFile(file, type) {
            if (!file.type.match('image/(jpeg|png)')) {
                showStatus('Format non supporté. Utilisez JPG ou PNG.', 'error');
                return;
            }

            const reader = new FileReader();
            reader.onload = (e) => {
                if (type === 'front') {
                    state.frontFile = file;
                    frontPreview.src = e.target.result;
                    frontPreview.style.display = 'block';
                    frontZone.querySelector('.content-empty').style.display = 'none';
                    frontZone.classList.add('filled');
                } else {
                    state.backFile = file;
                    backPreview.src = e.target.result;
                    backPreview.style.display = 'block';
                    backZone.querySelector('.content-empty').style.display = 'none';
                    backZone.classList.add('filled');
                }
                updateButtonState();
                status.style.display = 'none';
            };
            reader.readAsDataURL(file);
        }

        function updateButtonState() {
            if (state.isDoubleFace) {
                convertBtn.disabled = !(state.frontFile && state.backFile);
            } else {
                convertBtn.disabled = !state.frontFile;
            }
        }

        // --- Conversion Logic ---

        convertBtn.addEventListener('click', async () => {
            convertBtn.disabled = true;
            convertBtn.textContent = 'Génération...';
            status.style.display = 'none';

            try {
                // Read files as Data URLs
                const frontData = await readFileAsDataURL(state.frontFile);
                let backData = null;
                
                if (state.isDoubleFace) {
                    backData = await readFileAsDataURL(state.backFile);
                } else {
                    // In single mode, we conceptually use the front image for the back
                    // But our logic handles null backData by duplicating front logic
                    backData = frontData; 
                }

                // Create GLB
                const glbBlob = await generateCompositeGLB(frontData, backData, state.isDoubleFace);
                
                // Download
                const fileName = state.frontFile.name.replace(/\.[^/.]+$/, '') + (state.isDoubleFace ? '_double' : '') + '.glb';
                downloadGLB(glbBlob, fileName);
                
                showStatus('✓ GLB généré avec succès !', 'success');
            } catch (err) {
                console.error(err);
                showStatus('Erreur: ' + err.message, 'error');
            } finally {
                convertBtn.disabled = false;
                convertBtn.textContent = 'Convertir en GLB';
            }
        });

        function readFileAsDataURL(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = (e) => resolve(e.target.result);
                reader.onerror = reject;
                reader.readAsDataURL(file);
            });
        }

        async function generateCompositeGLB(frontDataUrl, backDataUrl, isDifferent) {
            return new Promise((resolve, reject) => {
                const img = new Image();
                img.onload = () => {
                    const aspectRatio = img.width / img.height;
                    try {
                        // We construct the binary data
                        const glb = createAdvancedCubeGLB(frontDataUrl, backDataUrl, aspectRatio, isDifferent);
                        resolve(glb);
                    } catch (e) {
                        reject(e);
                    }
                };
                img.onerror = () => reject(new Error('Impossible de charger l\'image principale'));
                img.src = frontDataUrl;
            });
        }

        function createAdvancedCubeGLB(frontImgData, backImgData, aspectRatio, isTwoTextures) {
            // Dimensions
            const width = aspectRatio;
            const height = 1;
            const depth = 0.001; 

            // --- Geometry Data ---
            // 24 vertices total
            const vertices = new Float32Array([
                // Front (Z+)
                -width/2, -height/2,  depth/2,
                 width/2, -height/2,  depth/2,
                 width/2,  height/2,  depth/2,
                -width/2,  height/2,  depth/2,
                // Back (Z-)
                -width/2, -height/2, -depth/2,
                -width/2,  height/2, -depth/2,
                 width/2,  height/2, -depth/2,
                 width/2, -height/2, -depth/2,
                // Top
                -width/2,  height/2, -depth/2,
                -width/2,  height/2,  depth/2,
                 width/2,  height/2,  depth/2,
                 width/2,  height/2, -depth/2,
                // Bottom
                -width/2, -height/2, -depth/2,
                 width/2, -height/2, -depth/2,
                 width/2, -height/2,  depth/2,
                -width/2, -height/2,  depth/2,
                // Right
                 width/2, -height/2, -depth/2,
                 width/2,  height/2, -depth/2,
                 width/2,  height/2,  depth/2,
                 width/2, -height/2,  depth/2,
                // Left
                -width/2, -height/2, -depth/2,
                -width/2, -height/2,  depth/2,
                -width/2,  height/2,  depth/2,
                -width/2,  height/2, -depth/2
            ]);

            const uvs = new Float32Array([
                // Front
                0, 1, 1, 1, 1, 0, 0, 0,
                // Back (Mirrored horizontally for correct reading if looked from behind)
                1, 1, 1, 0, 0, 0, 0, 1,
                // Top/Bot/Sides (Not really important as they are transparent)
                0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 0, 0, 0, 0, 0
            ]);

            // Indices split by material groups
            // Group 1: Front Face
            const indicesFront = new Uint16Array([0, 1, 2, 0, 2, 3]);
            
            // Group 2: Back Face
            const indicesBack = new Uint16Array([4, 5, 6, 4, 6, 7]);
            
            // Group 3: Sides (Top, Bot, Left, Right) - All Transparent
            const indicesSides = new Uint16Array([
                8, 9, 10,  8, 10, 11,   // Top
                12, 13, 14, 12, 14, 15, // Bottom
                16, 17, 18, 16, 18, 19, // Right
                20, 21, 22, 20, 22, 23  // Left
            ]);

            // --- Image Buffers ---
            const getBufferFromData = (dataUrl) => {
                const b64 = dataUrl.split(',')[1];
                return Uint8Array.from(atob(b64), c => c.charCodeAt(0));
            };

            const frontBuffer = getBufferFromData(frontImgData);
            let backBuffer = frontBuffer;
            let useSecondImage = false;

            if (isTwoTextures && backImgData) {
                backBuffer = getBufferFromData(backImgData);
                useSecondImage = true;
            }

            // --- Constructing GLTF JSON ---
            
            // Textures & Images
            // If single mode: 1 Image, 1 Texture
            // If double mode: 2 Images, 2 Textures
            const imagesDef = [{ bufferView: -1, mimeType: getMime(frontImgData) }];
            const texturesDef = [{ source: 0 }];
            
            if (useSecondImage) {
                imagesDef.push({ bufferView: -1, mimeType: getMime(backImgData) });
                texturesDef.push({ source: 1 });
            }

            // Materials
            // Mat 0: Front (Tex 0)
            // Mat 1: Back (Tex 0 OR Tex 1)
            // Mat 2: Transparent
            const materialsDef = [
                {
                    name: "FrontMaterial",
                    pbrMetallicRoughness: {
                        baseColorTexture: { index: 0 },
                        metallicFactor: 0, roughnessFactor: 1
                    },
                    alphaMode: "BLEND"
                },
                {
                    name: "BackMaterial",
                    pbrMetallicRoughness: {
                        baseColorTexture: { index: useSecondImage ? 1 : 0 },
                        metallicFactor: 0, roughnessFactor: 1
                    },
                    alphaMode: "BLEND"
                },
                {
                    name: "InvisibleMaterial",
                    pbrMetallicRoughness: {
                        baseColorFactor: [0, 0, 0, 0], // Fully transparent
                        metallicFactor: 0, roughnessFactor: 1
                    },
                    alphaMode: "BLEND"
                }
            ];

            // Accessors needed: 
            // 0: Position (Vec3)
            // 1: UV (Vec2)
            // 2: Indices Front
            // 3: Indices Back
            // 4: Indices Sides
            
            // Buffer Views Mapping (calculated later):
            // 0: Vertices
            // 1: UVs
            // 2: Indices Front
            // 3: Indices Back
            // 4: Indices Sides
            // 5: Image 1
            // 6: Image 2 (Optional)

            const json = {
                asset: { version: "2.0", generator: "Advanced Texture GLB" },
                scene: 0,
                scenes: [{ nodes: [0] }],
                nodes: [{ mesh: 0 }],
                meshes: [{
                    primitives: [
                        { attributes: { POSITION: 0, TEXCOORD_0: 1 }, indices: 2, material: 0 }, // Front
                        { attributes: { POSITION: 0, TEXCOORD_0: 1 }, indices: 3, material: 1 }, // Back
                        { attributes: { POSITION: 0, TEXCOORD_0: 1 }, indices: 4, material: 2 }  // Sides
                    ]
                }],
                materials: materialsDef,
                textures: texturesDef,
                images: imagesDef,
                accessors: [
                    { bufferView: 0, componentType: 5126, count: 24, type: "VEC3", min: [-width/2, -height/2, -depth/2], max: [width/2, height/2, depth/2] }, // Pos
                    { bufferView: 1, componentType: 5126, count: 24, type: "VEC2" }, // UV
                    { bufferView: 2, componentType: 5123, count: 6, type: "SCALAR" }, // Idx Front
                    { bufferView: 3, componentType: 5123, count: 6, type: "SCALAR" }, // Idx Back
                    { bufferView: 4, componentType: 5123, count: 24, type: "SCALAR" }  // Idx Sides
                ],
                bufferViews: [], // Filled dynamically
                buffers: [] // Filled dynamically
            };

            // Calculate Offsets
            const bufferViews = [];
            let currentOffset = 0;
            const bufferChunks = [vertices, uvs, indicesFront, indicesBack, indicesSides];
            
            // Geometry Views
            bufferChunks.forEach((chunk, i) => {
                const len = chunk.byteLength;
                bufferViews.push({ buffer: 0, byteOffset: currentOffset, byteLength: len });
                currentOffset += len;
                // Add padding to 4 bytes
                while(currentOffset % 4 !== 0) { currentOffset++; }
            });

            // Image 1 View
            const img1Index = bufferViews.length;
            json.images[0].bufferView = img1Index;
            bufferViews.push({ buffer: 0, byteOffset: currentOffset, byteLength: frontBuffer.byteLength });
            currentOffset += frontBuffer.byteLength;
            while(currentOffset % 4 !== 0) { currentOffset++; }

            // Image 2 View (if exists)
            if (useSecondImage) {
                const img2Index = bufferViews.length;
                json.images[1].bufferView = img2Index;
                bufferViews.push({ buffer: 0, byteOffset: currentOffset, byteLength: backBuffer.byteLength });
                currentOffset += backBuffer.byteLength;
                while(currentOffset % 4 !== 0) { currentOffset++; }
            }

            json.bufferViews = bufferViews;
            json.buffers = [{ byteLength: currentOffset }];

            // Build Binary
            const finalBuffer = new Uint8Array(currentOffset);
            let writePos = 0;

            // Write Geometry
            bufferChunks.forEach(chunk => {
                const view = chunk instanceof Float32Array || chunk instanceof Uint16Array 
                    ? new Uint8Array(chunk.buffer) : chunk;
                finalBuffer.set(view, writePos);
                writePos += view.byteLength;
                while(writePos % 4 !== 0) { finalBuffer[writePos] = 0; writePos++; } // Padding
            });

            // Write Image 1
            finalBuffer.set(frontBuffer, writePos);
            writePos += frontBuffer.byteLength;
            while(writePos % 4 !== 0) { finalBuffer[writePos] = 0; writePos++; }

            // Write Image 2
            if (useSecondImage) {
                finalBuffer.set(backBuffer, writePos);
                writePos += backBuffer.byteLength;
                while(writePos % 4 !== 0) { finalBuffer[writePos] = 0; writePos++; }
            }

            return buildGLB(json, finalBuffer);
        }

        function getMime(dataUrl) {
            return dataUrl.startsWith('data:image/png') ? "image/png" : "image/jpeg";
        }

        function buildGLB(json, binaryBuffer) {
            const jsonString = JSON.stringify(json);
            const jsonBuffer = new TextEncoder().encode(jsonString);
            
            // Padding JSON to 4 bytes with spaces (0x20)
            const jsonPadding = (4 - (jsonBuffer.length % 4)) % 4;
            const jsonChunkLength = jsonBuffer.length + jsonPadding;

            // Padding Binary to 4 bytes with zeros (already handled in creation, but good for header calc)
            // binaryBuffer is already padded in my logic above to 4 byte alignment
            const binChunkLength = binaryBuffer.length; 

            const totalLength = 12 + 8 + jsonChunkLength + 8 + binChunkLength;

            const glb = new ArrayBuffer(totalLength);
            const view = new DataView(glb);
            let pos = 0;

            // Header
            view.setUint32(pos, 0x46546C67, true); pos += 4; // magic
            view.setUint32(pos, 2, true); pos += 4; // version
            view.setUint32(pos, totalLength, true); pos += 4; // total length

            // JSON Chunk
            view.setUint32(pos, jsonChunkLength, true); pos += 4;
            view.setUint32(pos, 0x4E4F534A, true); pos += 4; // JSON
            new Uint8Array(glb, pos, jsonBuffer.length).set(jsonBuffer); pos += jsonBuffer.length;
            for (let i = 0; i < jsonPadding; i++) view.setUint8(pos++, 0x20);

            // Binary Chunk
            view.setUint32(pos, binChunkLength, true); pos += 4;
            view.setUint32(pos, 0x004E4942, true); pos += 4; // BIN
            new Uint8Array(glb, pos, binaryBuffer.length).set(binaryBuffer);

            return new Blob([glb], { type: 'model/gltf-binary' });
        }

        function downloadGLB(blob, fileName) {
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = fileName;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        function showStatus(message, type) {
            status.textContent = message;
            status.className = 'status ' + type;
            status.style.display = 'block';
        }
    </script>
</body>
</html>